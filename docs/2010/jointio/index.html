<html>
<head>
<link rel="stylesheet" type="text/css" href="../css/main.css" />
<title>JointIO Board</title>
</head>
<body>
<center><h1>JointIO Board</h1></center>
Robots need sensors. Without them, they drive into walls, miss tokens, catch fire, take over the world... you get the idea. To enable your robot to get information about the immediate world around it, you are provided with the JointIO board in your kit. JointIO stands for Joint Input and Output. You can connect different types of electrical sensors to it (Inputs) and drive additional circuitry or devices (Outputs).

<h2>Board Outline</h2>
<center>
<a name="board-outline"></>
<a href="images/outline.png"><img src="images/outline.png" style="width:300px" border=0 /></a>
<br />Figure 1 - Outline of JointIO Board (click full size image)
</center>

<h2>Types of Sensor</h2>
Electrical sensors fall in to two categories, analogue and digital. Analogue sensors include:
<ul>
<li>Potentiometers (variable resistors)</li>
<li>Light detectors (photo-diodes, photo-resistors)</li>
<li>Sound detectors (microphones)</li>
<li>Temperature sensors (thermistors, thermocouples)</li>
</ul>
Analogue sensors produce a signal which can vary in magnitude over a range of possible values. Compare this to digital sensors which can only have one of two values 1 or 0 (on/off, true/false, ...). Digital sensors include:
<ul>
<li>Mechanical Tilt sensors </li>
<li>Reed sensors </li>
<li>Bump switches</li>
<li>Signals from other digital electronics</li>
</ul>

<h2> Technical Specification</h2>
<ul>
<li>There are 8 available inputs on the JointIO board</li>
<li>Each input can be connected to a digital OR analogue sensor</li>
<li>There are 4 available digital outputs</li>
<li>There are 4 ground connections</li>
<li>There are 4 power connections (3.3 Volts)</li>
</ul>

<h2>Making Connections</h2>
All connections to the JointIO board are made using the green and orange cage clamps located on all sides of the board. You will need to refer to the <a href="#board-outline">Board Outline</a> <b>before making any connections!</b> Using a small screwdriver you can push back the orange lever on the cage clamp and insert the wire directly into the hole on the front. Release the orange lever and ensure that the wire is held tightly.

<h2>Inputs</h2>
Eight analogue inputs are provided by the JointIO Board. These are labelled 0 to 7 and can be treated as <strong>digital</strong> inputs in your code if desired. Power and ground connections are provided to enable switches and external circuits to be interfaced. <a href="#analogue-in">Figure 2</a> demonstrates how a rotary potentiometer can be connected to the JointIO board to measure angular rotation. <br />
<br />
<strong>Note:</strong> The analogue readings of the input pin assume that the input voltage range is between GND and 3.3V. If a voltage greater than 3.3V is connected, the JointIO board will still read it as 3.3V. If you have inputs which are unused i.e. not connected to anything, then their value, if read, will fluctuate randomly between 0 and 3.3Volts. To repeat that, <strong>Unconnected inputs will have random analogue values</strong>. 
<br />
<br />
The logic value of these input pins are echoed onto the input LEDs on the board. This gives a visual indication of which inputs are high/low.

<center>
<a name="analogue-in"></>
<a href="images/analogue-in.png"><img src="images/analogue-in.png" border=0 /></a>
<br />Figure 2 - Example analogue sensor circuit
</center>
<br />
<a href="#digital-in">Figure 3</a> shows how a simple bump switch may be connected to the JointIO board. Note that the resistor (typical values ~1k) is necessary so that when the switch is not pressed, the JointIO input is not disconnected, instead it is 'pulled' to ground. Remember, disconnected inputs have random values!
<center>
<a name="digital-in"></>
<a href="images/digital-in.png"><img src="images/digital-in.png" border=0 /></a>
<br />Figure 3 - Example digital sensor circuit
</center>

<h2>Outputs</h2>
Four digital outputs are provided by the JointIO Board. These are labelled 0 to 3 and may be used to trigger relays, LEDs, external logic circuits or anything else requiring a digital signal. The digital output pins will be at 3.3V (Logic 1) and GND (Logic 0). The logic value of each output pin is displayed by the output LEDs on the board. This gives a visual indication of which outputs are high/low.

<h2>Troubleshooting</h2>
<h3>The input pin value appears to be random</h3>
Most likely you are reading a pin which is not physically connected to anything and therefore it is floating. This could be because you are reading the wrong pin or because the connection to the cage clamp is loose.

<h3>The input pin value is always 3.3</h3>
The maximum input voltage to the JointIO is 3.3V, if a voltage greater than this is connected, the value read by the JointIO board will always read 3.3V.

<h1>Programming Interface</h1>
A programming interface is a set of rules explaining how you can control a specific module from within your robot's python code.

<h3>Reading Inputs</h3>
To get the analogue value of a specific input use the following command:
<pre>
# INPUT_NUMBER = 0,1,..7
io.apin[INPUT_NUMBER]
</pre>
This will return a real number between 0 and 3.3.

<br />
<br />
To get the digital value of a specific input use the following command:
<pre>
# INPUT_NUMBER = 0,1,..7
io.pin[INPUT_NUMBER]
</pre>
Note that 'apin' becomes 'pin' for digital reads.

<h3>Setting Outputs</h3>
To set one of the four output pins use the following commands:
<pre>
# OUTPUT_NUMBER = 0,1,2,3
io.pin[1] = 1

# Or:
setoutput(OUTPUT_NUMBER,1)

#examples:
#set output 1 high
io.pin[1] = 1
setoutput(1, 1)

#set output 3 low
io.pin[3] = 0
setoutput(3,0)
</pre>

<h3>Events</h3>
The real word is full of events which you must react to. The same is true for your robot's world. Your robot will need to react to the events when they happen, such as finding a token, hitting a wall or catching on fire. There are two ways your robot can find out that an event has occurred. 
<ol>
<li><b>Polling:</b> The robot continually checks for each possible event one by one in an infinite loop until something happens.</li>
<li><b>Yielding:</b> The robot waits or 'yields' on a particular event. When that event occurs your robot will be interrupted but in the meantime it can get on with other tasks, like finding tokens.
</li>
</ol>

A common problem is needing to wait for a bump switch to be triggered, in which case you might need to change the direction of your robot. This waiting can be achieved using the yield statement:
<pre>
# our bump sensor is connected to input 0
yield io.pin[0]
</pre>
The above code will cause your robot to wait until the digital value of the JointIO input pin 0 to change from its current value. Until it does, any code that follows the yield statement will not be executed. Suppose that you are only interested in when an input is at a particular value, the following code shows you how you can specify the conditions within the yield statement:
<pre>
# Wait for input 3 to change digital value
yield io.pin[3]

# Wait for input 3 to become digital '1' (threshold 512)
yield io.pin[3] == 1

# Wait for input 3 reading to exceed 1V
yield io.apin[3] > 1

# Wait for input 2 reading to go below 2.5V
yield io.apin[2] < 2.5

# note analogue pins do not have the '==' operator
</pre>

More complex events might occur when multiple inputs change or are in specific states. It is possible to wait on multiple input events within the same yield statement
<pre>
# wait for input pin 3 to be logic 1 AND input pin 2 to be logic 0
yield (io.pin[3] == 1) & (io.pin[2] == 0)

# wait for input pin 3 to be greater than 2V AND below 3V
yield (io.apin[3] > 2) & (io.apin[3] < 3)

# wait for input pin 5 to be logic 1 OR input pin 4 to be logic 0
yield (io.pin[5] == 1) , (io.pin[4] == 0)

# wait for input pin 3 to be greater than 2V OR input 4 to be below 3V
yield (io.apin[3] > 2) , (io.apin[4] < 3)
</pre>

<h3>Dealing with an event</h3>
How do you deal with an event when it happens? Well, the first step is to find out exactly what it is that has happened. This information is stored in the 'event' variable. Immediately after a yield, you can test the event variable to find out the state of the input pins when the event occurred. This information is particularly useful when you yield on multiple events as you need to identify which one has occurred. 

The following code yields on two different input pins (0 & 1) and then updates two output pins such that they echo the input values. The routine is utterly pointless and could be replaced with a piece of wire, but it illustrates how to deal with an event.
<pre>
#wait until either input 0 or input 1 changes value
yield io.pin[0], io.pin[1]

# event.io.pins is a list of the pins which caused the event and the yield to return
if 0 in event.io.pins:
	# event.io.vals is a list of the pin values when the event happened
	# e.g. event.io.vals[0] gives the value of pin 0 which triggered the event
	# event.io.vals only contains pin values for the pins in yield statement

	# the pin 0 event occurred, so we need to update output 0
	io.pin[0] = event.io.vals[0]

elif 1 in event.io.pins:
	# the pin 1 event occurred, we need to update output 1
	io.pin[1] = event.io.vals[1]

</pre>

When yielding on different types of events such as JointIO inputs and vision, you can use the event variable to find out which type of event occurred:

<pre>
# see vision documentation for more info
yield vision(), io.pin[0]
if event == io:
	# Input pin 0 triggered the event
	pass
if event == vision:
	# a vision event happened before input pin 0 changed
	pass
</pre>


</body>
