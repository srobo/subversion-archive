\documentclass{article}
\usepackage{times}
\usepackage{natbib}
\usepackage{url}
\usepackage{textcomp}
\bibpunct{(}{)}{;}{a}{,}{,}
\begin{document}
\title{Student Robotics Programming Reference}
\date{\today}
\maketitle
\begin{abstract}
This document details the programming interface to be used when programming a
Student Robotics robot.  For more information on programming in Python and
about how to bring all this together see the tutorial.
\end{abstract}
\section{Directory structure}
Code must be contained within a zip file named robot.zip which acts as a Python
module.  The zip file must contain at least two files named
\texttt{__init__.py} and \texttt{robot.py}.  Other \texttt{.py} files can be
included to seperate code so it is more organised.  The Checkout function of
the RoboIDE system creates zip files in this format.
\subsection{__init__.py}
This file is used so Python can identify the zip file as a compressed module.
It should be empty.
\subsection{robot.py}
This file must contain at least the main function for the robot control
algorithm.
\subsection{File structure}
\subsubsection{Imports}
All files containg parts of the robot control algorithm must import the Student
Robotics interface components with: \texttt{from sr import *}.  Other standard
Python modules can be imported as required.
\section{Main function}
In the \texttt{robot.py} file there must be a function with the form:

\texttt{def main(corner, colour, game):}

When the robot is started, this function will be called.
\section{Yielding control and interrupts}
Once the main function is called, the algorithm has control of the robot.  The
algorithm must \texttt{yield} control of the robot once it has configured any
outputs.  The \texttt{yield} command passes control of the robot over to the
Student Robotics environment which will pass control back to the instruction
after the \texttt{yield} statement.  When control is passed back to the
algorithm the event variable is set to contain information 
\subsection{Using \texttt{yield}}
\subsubsection{Timeouts}
The \texttt{yield} statement can be used to wait for a set amount of time:

\texttt{yield 4}

Causes the algorithm to be delayed for 4 seconds.
\subsubsection{Waiting on events}
The \texttt{yield} statement can be used to wait for an event to occur:

\texttt{yield dio}

Causes the algorithm to wait until a dio (digital IO) event is received.
\subsubsection{Combinations of events and timeout}
The \texttt{yield} statement can be used to wait on a combination of events and
a timeout, whichever occurs first:

\texttt{yield dio, 5}

Causes the algorithm to wait until a dio event is received or 5 seconds,
whichever comes first.
\subsubsection{Calling subroutines}
Control of the robot can be passed to subroutines, allowing the algorithm to be
split up into easier to understand parts.  The \texttt{yield} statement can be
used to pass control of the robot to a subroutine.  When the subroutine returns
the algorithm continues from the yield statement.  If more information is
passed to yield after the name of a subroutine, then that information is passed
as an argument to that subroutine.

\texttt{yield findTokens, 3}

Causes control of the robot to be passed to the findTokens subroutine with the
argument 3.
\subsection{The \texttt{event} variable}
The \texttt{event} variable is set when control is returned to the algorithm
after a yield. It contains information regarding the event that caused control
to be passed back to the algorithm.
\subsubsection{Finding the event source}
The \texttt{event} variable will return true when compared to the event source that led
to its creation:

\begin{verbatim}
yield dio, 5 #Wait until a dio event or 5 seconds passes

if event == dio:
    pass #A dio event happened first (pass means do-nothing)
else:
    pass #A timeout is the only other option
\end{verbatim}
\subsection{Digital IO Events}
Digital IO events are caused by a change of the digital inputs to the Joint IO
board. After a dio event causes a \texttt{yield} statement to return control of
the robot to the control algorithm, the \texttt{event} variable will be set.
The dio inputs that have changed are contained in a dictionary called
\texttt{pins} that can be accessed from \texttt{dio.pins}:

\begin{verbatim}
yield dio, 5

if event == dio:               #Is it a dio event?
    if 0 in event.pins:        #Has input 0 been changed?
        if event.pins[0] == 1: #Is input 0 now a 1?
            pass
\end{verbatim}
\subsection{Visual Events}
When control is yielded and the \texttt{vision} event source is passed to the
\texttt{yield} command the robot will grab an image with its webcam and start
to process that image.  When this processing has finished, the vision system
will raise an event (whether a token is seen or not).  Any tokens found are
contained in a list called \texttt{blobs} that can be accessed through
\texttt{event.blobs}.  Each blob in this list has a set of properties:
\begin{reference}
\item[\texttt{colour}] The colour of the blob
\item[\texttt{mass}] The number of pixels that make up the blob
\item[\texttt{centrex} The number of pixels from the left of the image of the centre
of the blob left to right.
\item[\texttt{centrey}] The number of pixels from the top of the image to the
centre of the blob top to bottom.
\end{reference}
\section{Event sources}
\subsection{
\end{document}
